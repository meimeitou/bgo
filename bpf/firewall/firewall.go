//go:build !ignore_autogenerated

package firewall

import (
	"context"
	"encoding/binary"
	"fmt"
	"net"
	"net/http"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type fw_rule -type fw_stats firewall firewall.c -- -I../../lib/common
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type tc_rule -type firewall_tc_stats firewall_tc firewall_tc.c -- -I../../lib/common

const (
	// MaxRules defines the maximum number of rules we can handle (using #pragma unroll)
	MaxRules = 50
	PinPath  = "/sys/fs/bpf"
)

// Protocol constants matching BPF code
const (
	ProtocolTCP  = 6
	ProtocolUDP  = 17
	ProtocolICMP = 1
	ProtocolAny  = 0
)

// Action constants
const (
	ActionBlock = 0
	ActionAllow = 1
)

// Config map keys
const (
	ConfigWhitelistEnabled = 0
	ConfigBlacklistEnabled = 1
	ConfigDefaultAction    = 2
)

// TC firewall constants
const (
	TCRuleTypeWhitelist = 0
	TCRuleTypeBlacklist = 1
	TCDirectionIngress  = 0
	TCDirectionEgress   = 1
	TCActionAllow       = 0
	TCActionDeny        = 1
)

// Rule represents a firewall rule
type Rule struct {
	IPStart  net.IP `json:"ip_start"`
	IPEnd    net.IP `json:"ip_end"`
	Port     uint16 `json:"port"`
	Protocol uint8  `json:"protocol"`
	Action   uint8  `json:"action"`
}

// Stats represents firewall statistics
type Stats struct {
	TotalPackets   uint64 `json:"total_packets"`
	AllowedPackets uint64 `json:"allowed_packets"`
	BlockedPackets uint64 `json:"blocked_packets"`
}

// TCRule represents a TC firewall rule with whitelist/blacklist support
type TCRule struct {
	IPStart   uint32 `json:"ip_start"`
	IPEnd     uint32 `json:"ip_end"`
	Port      uint16 `json:"port"`
	Protocol  uint8  `json:"protocol"`  // 0=ANY, 1=ICMP, 6=TCP, 17=UDP
	RuleType  uint8  `json:"rule_type"` // 0=WHITELIST, 1=BLACKLIST
	Action    uint8  `json:"action"`    // 0=ALLOW, 1=DENY (mainly for default action)
	Direction uint8  `json:"direction"` // 0=INGRESS, 1=EGRESS
}

// TCStats represents TC firewall statistics
type TCStats struct {
	TotalPackets   uint64 `json:"total_packets"`
	AllowedPackets uint64 `json:"allowed_packets"`
	DeniedPackets  uint64 `json:"denied_packets"`
	IngressPackets uint64 `json:"ingress_packets"`
	EgressPackets  uint64 `json:"egress_packets"`
}

// XDPFirewall manages XDP firewall functionality
type XDPFirewall struct {
	objs    *firewallObjects
	link    link.Link
	iface   string
	pinPath string
	pinned  bool
}

// NewXDPFirewall creates a new XDP firewall instance
func NewXDPFirewall(iface string) (*XDPFirewall, error) {
	return NewXDPFirewallWithPin(iface, "")
}

// NewXDPFirewallWithPin creates a new XDP firewall instance with optional pinning
func NewXDPFirewallWithPin(iface, pinPath string) (*XDPFirewall, error) {
	// Remove memory limit for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memory limit: %w", err)
	}

	fw := &XDPFirewall{
		iface:   iface,
		pinPath: pinPath,
	}

	// Try to load from pinned maps first if pin path is provided
	if pinPath != "" {
		if err := fw.loadFromPinned(); err != nil {
			// If loading from pinned fails, create new
			if err := fw.loadNew(); err != nil {
				return nil, err
			}
		} else {
			fw.pinned = true
		}
	} else {
		if err := fw.loadNew(); err != nil {
			return nil, err
		}
	}

	return fw, nil
}

// loadNew loads a new eBPF program
func (fw *XDPFirewall) loadNew() error {
	var opts *ebpf.CollectionOptions
	if fw.pinPath != "" {
		opts = &ebpf.CollectionOptions{
			Maps: ebpf.MapOptions{
				PinPath: fw.pinPath,
			},
		}
	}

	objs := &firewallObjects{}
	if err := loadFirewallObjects(objs, opts); err != nil {
		return fmt.Errorf("failed to load eBPF objects: %w", err)
	}

	fw.objs = objs

	// Initialize config with default values
	if err := fw.initializeConfig(); err != nil {
		return fmt.Errorf("failed to initialize config: %w", err)
	}

	return nil
}

// loadFromPinned loads from existing pinned maps
func (fw *XDPFirewall) loadFromPinned() error {
	if fw.pinPath == "" {
		return fmt.Errorf("pin path is required")
	}

	// Load pinned maps
	whitelistMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/whitelist_map", &ebpf.LoadPinOptions{})
	if err != nil {
		return fmt.Errorf("failed to load pinned whitelist map: %w", err)
	}

	blacklistMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/blacklist_map", &ebpf.LoadPinOptions{})
	if err != nil {
		whitelistMap.Close()
		return fmt.Errorf("failed to load pinned blacklist map: %w", err)
	}

	statsMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/stats_map", &ebpf.LoadPinOptions{})
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		return fmt.Errorf("failed to load pinned stats map: %w", err)
	}

	configMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/config_map", &ebpf.LoadPinOptions{})
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		statsMap.Close()
		return fmt.Errorf("failed to load pinned config map: %w", err)
	}

	// Load the program (this won't be pinned, but we need it for attachment)
	spec, err := loadFirewall()
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		statsMap.Close()
		configMap.Close()
		return fmt.Errorf("failed to load program spec: %w", err)
	}

	prog, err := ebpf.NewProgram(spec.Programs["xdp_firewall"])
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		statsMap.Close()
		configMap.Close()
		return fmt.Errorf("failed to create program: %w", err)
	}

	fw.objs = &firewallObjects{}
	fw.objs.XdpFirewall = prog
	fw.objs.WhitelistMap = whitelistMap
	fw.objs.BlacklistMap = blacklistMap
	fw.objs.StatsMap = statsMap
	fw.objs.ConfigMap = configMap

	return nil
}

// initializeConfig sets up default configuration
func (fw *XDPFirewall) initializeConfig() error {
	// Set default values
	configs := map[uint32]uint32{
		ConfigWhitelistEnabled: 1, // Enable whitelist by default
		ConfigBlacklistEnabled: 1, // Enable blacklist by default
		ConfigDefaultAction:    1, // Default to PASS
	}

	for key, value := range configs {
		if err := fw.objs.ConfigMap.Put(key, value); err != nil {
			return fmt.Errorf("failed to set config %d: %w", key, err)
		}
	}

	// Initialize stats
	stats := firewallFwStats{}
	if err := fw.objs.StatsMap.Put(uint32(0), stats); err != nil {
		return fmt.Errorf("failed to initialize stats: %w", err)
	}

	return nil
}

// Attach attaches the XDP program to the network interface
func (fw *XDPFirewall) Attach() error {
	if fw.link != nil {
		return fmt.Errorf("firewall is already attached")
	}

	// Get interface index
	iface, err := net.InterfaceByName(fw.iface)
	if err != nil {
		return fmt.Errorf("failed to find interface %s: %w", fw.iface, err)
	}

	l, err := link.AttachXDP(link.XDPOptions{
		Program:   fw.objs.XdpFirewall,
		Interface: iface.Index,
		Flags:     link.XDPGenericMode,
	})
	if err != nil {
		return fmt.Errorf("failed to attach XDP program: %w", err)
	}

	fw.link = l
	return nil
}

// Detach detaches the XDP program from the network interface
func (fw *XDPFirewall) Detach() error {
	if fw.link != nil {
		if err := fw.link.Close(); err != nil {
			return fmt.Errorf("failed to detach XDP program: %w", err)
		}
		fw.link = nil
	}
	return nil
}

// Close cleans up resources
func (fw *XDPFirewall) Close() error {
	if err := fw.Detach(); err != nil {
		return err
	}

	if fw.objs != nil {
		fw.objs.Close()
	}
	return nil
}

// AddWhitelistRule adds a rule to the whitelist
func (fw *XDPFirewall) AddWhitelistRule(rule Rule) error {
	return fw.addRule(&fw.objs.WhitelistMap, rule)
}

// AddBlacklistRule adds a rule to the blacklist
func (fw *XDPFirewall) AddBlacklistRule(rule Rule) error {
	return fw.addRule(&fw.objs.BlacklistMap, rule)
}

// addRule adds a rule to the specified map
func (fw *XDPFirewall) addRule(targetMap **ebpf.Map, rule Rule) error {
	// Find an empty slot
	for i := uint32(0); i < MaxRules; i++ {
		var existingRule firewallFwRule
		err := (*targetMap).Lookup(i, &existingRule)
		if err != nil || existingRule.IpStart == 0 {
			// Empty slot found
			bpfRule := firewallFwRule{
				IpStart:  IPToUint32(rule.IPStart),
				IpEnd:    IPToUint32(rule.IPEnd),
				Port:     rule.Port,
				Protocol: rule.Protocol,
				Action:   rule.Action,
			}
			return (*targetMap).Put(i, bpfRule)
		}
	}
	return fmt.Errorf("no available slots (max %d rules)", MaxRules)
}

// RemoveWhitelistRule removes a rule from the whitelist
func (fw *XDPFirewall) RemoveWhitelistRule(index uint32) error {
	return fw.removeRule(&fw.objs.WhitelistMap, index)
}

// RemoveBlacklistRule removes a rule from the blacklist
func (fw *XDPFirewall) RemoveBlacklistRule(index uint32) error {
	return fw.removeRule(&fw.objs.BlacklistMap, index)
}

// removeRule removes a rule from the specified map
func (fw *XDPFirewall) removeRule(targetMap **ebpf.Map, index uint32) error {
	if index >= MaxRules {
		return fmt.Errorf("index %d out of range (max %d)", index, MaxRules-1)
	}

	// Clear the rule by setting it to zero values
	emptyRule := firewallFwRule{}
	return (*targetMap).Put(index, emptyRule)
}

// ListWhitelistRules lists all whitelist rules
func (fw *XDPFirewall) ListWhitelistRules() ([]Rule, error) {
	return fw.listRules(&fw.objs.WhitelistMap)
}

// ListBlacklistRules lists all blacklist rules
func (fw *XDPFirewall) ListBlacklistRules() ([]Rule, error) {
	return fw.listRules(&fw.objs.BlacklistMap)
}

// listRules lists all rules from the specified map
func (fw *XDPFirewall) listRules(targetMap **ebpf.Map) ([]Rule, error) {
	var rules []Rule

	for i := uint32(0); i < MaxRules; i++ {
		var bpfRule firewallFwRule
		if err := (*targetMap).Lookup(i, &bpfRule); err != nil {
			continue
		}

		if bpfRule.IpStart != 0 {
			rule := Rule{
				IPStart:  Uint32ToIP(bpfRule.IpStart),
				IPEnd:    Uint32ToIP(bpfRule.IpEnd),
				Port:     bpfRule.Port,
				Protocol: bpfRule.Protocol,
				Action:   bpfRule.Action,
			}
			rules = append(rules, rule)
		}
	}

	return rules, nil
}

// GetStats returns current firewall statistics
func (fw *XDPFirewall) GetStats() (*Stats, error) {
	var bpfStats firewallFwStats
	if err := fw.objs.StatsMap.Lookup(uint32(0), &bpfStats); err != nil {
		return nil, fmt.Errorf("failed to get stats: %w", err)
	}

	return &Stats{
		TotalPackets:   bpfStats.TotalPackets,
		AllowedPackets: bpfStats.AllowedPackets,
		BlockedPackets: bpfStats.BlockedPackets,
	}, nil
}

// SetConfig sets a configuration value
func (fw *XDPFirewall) SetConfig(key, value uint32) error {
	return fw.objs.ConfigMap.Put(key, value)
}

// GetConfig gets a configuration value
func (fw *XDPFirewall) GetConfig(key uint32) (uint32, error) {
	var value uint32
	err := fw.objs.ConfigMap.Lookup(key, &value)
	return value, err
}

// IPToUint32 converts IP address to uint32 (network byte order)
func IPToUint32(ip net.IP) uint32 {
	if ip == nil {
		return 0
	}
	ip = ip.To4()
	if ip == nil {
		return 0
	}
	return binary.LittleEndian.Uint32(ip)
}

// Uint32ToIP converts uint32 to IP address (network byte order)
func Uint32ToIP(val uint32) net.IP {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, val)
	return ip
}

// ParseCIDR parses CIDR notation and returns start and end IP addresses
func ParseCIDR(cidr string) (net.IP, net.IP, error) {
	_, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		return nil, nil, err
	}

	startIP := ipNet.IP
	endIP := make(net.IP, len(startIP))
	copy(endIP, startIP)

	// Calculate end IP
	for i := 0; i < len(endIP); i++ {
		endIP[i] |= ^ipNet.Mask[i]
	}

	return startIP, endIP, nil
}

// FirewallManager provides CLI interface for managing pinned maps
type FirewallManager struct {
	pinPath string
}

// NewFirewallManager creates a new firewall manager for CLI operations
func NewFirewallManager(pinPath string) *FirewallManager {
	if pinPath == "" {
		pinPath = PinPath
	}
	return &FirewallManager{pinPath: pinPath}
}

// AddWhitelistRule adds a rule to the whitelist via pinned maps
func (fm *FirewallManager) AddWhitelistRule(rule Rule) error {
	mapPath := fmt.Sprintf("%s/whitelist_map", fm.pinPath)
	return fm.addRuleToMap(mapPath, rule)
}

// AddBlacklistRule adds a rule to the blacklist via pinned maps
func (fm *FirewallManager) AddBlacklistRule(rule Rule) error {
	mapPath := fmt.Sprintf("%s/blacklist_map", fm.pinPath)
	return fm.addRuleToMap(mapPath, rule)
}

// addRuleToMap adds a rule to the specified pinned map
func (fm *FirewallManager) addRuleToMap(mapPath string, rule Rule) error {
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return fmt.Errorf("failed to load pinned map %s: %w", mapPath, err)
	}
	defer m.Close()

	// Find an empty slot
	for i := uint32(0); i < MaxRules; i++ {
		var existingRule firewallFwRule
		err := m.Lookup(i, &existingRule)
		if err != nil || existingRule.IpStart == 0 {
			// Empty slot found
			bpfRule := firewallFwRule{
				IpStart:  IPToUint32(rule.IPStart),
				IpEnd:    IPToUint32(rule.IPEnd),
				Port:     rule.Port,
				Protocol: rule.Protocol,
				Action:   rule.Action,
			}
			return m.Put(i, bpfRule)
		}
	}
	return fmt.Errorf("no available slots (max %d rules)", MaxRules)
}

// RemoveWhitelistRule removes a rule from the whitelist
func (fm *FirewallManager) RemoveWhitelistRule(index uint32) error {
	mapPath := fmt.Sprintf("%s/whitelist_map", fm.pinPath)
	return fm.removeRuleFromMap(mapPath, index)
}

// RemoveBlacklistRule removes a rule from the blacklist
func (fm *FirewallManager) RemoveBlacklistRule(index uint32) error {
	mapPath := fmt.Sprintf("%s/blacklist_map", fm.pinPath)
	return fm.removeRuleFromMap(mapPath, index)
}

// removeRuleFromMap removes a rule from the specified pinned map
func (fm *FirewallManager) removeRuleFromMap(mapPath string, index uint32) error {
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return fmt.Errorf("failed to load pinned map %s: %w", mapPath, err)
	}
	defer m.Close()

	if index >= MaxRules {
		return fmt.Errorf("index %d out of range (max %d)", index, MaxRules-1)
	}

	// Clear the rule by setting it to zero values
	emptyRule := firewallFwRule{}
	return m.Put(index, emptyRule)
}

// ListWhitelistRules lists all whitelist rules
func (fm *FirewallManager) ListWhitelistRules() ([]Rule, error) {
	mapPath := fmt.Sprintf("%s/whitelist_map", fm.pinPath)
	return fm.listRulesFromMap(mapPath)
}

// ListBlacklistRules lists all blacklist rules
func (fm *FirewallManager) ListBlacklistRules() ([]Rule, error) {
	mapPath := fmt.Sprintf("%s/blacklist_map", fm.pinPath)
	return fm.listRulesFromMap(mapPath)
}

// listRulesFromMap lists all rules from the specified pinned map
func (fm *FirewallManager) listRulesFromMap(mapPath string) ([]Rule, error) {
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to load pinned map %s: %w", mapPath, err)
	}
	defer m.Close()

	var rules []Rule
	for i := uint32(0); i < MaxRules; i++ {
		var bpfRule firewallFwRule
		if err := m.Lookup(i, &bpfRule); err != nil {
			continue
		}

		if bpfRule.IpStart != 0 {
			rule := Rule{
				IPStart:  Uint32ToIP(bpfRule.IpStart),
				IPEnd:    Uint32ToIP(bpfRule.IpEnd),
				Port:     bpfRule.Port,
				Protocol: bpfRule.Protocol,
				Action:   bpfRule.Action,
			}
			rules = append(rules, rule)
		}
	}

	return rules, nil
}

// GetStats returns current firewall statistics from pinned maps
func (fm *FirewallManager) GetStats() (*Stats, error) {
	mapPath := fmt.Sprintf("%s/stats_map", fm.pinPath)
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to load pinned stats map: %w", err)
	}
	defer m.Close()

	var bpfStats firewallFwStats
	if err := m.Lookup(uint32(0), &bpfStats); err != nil {
		return nil, fmt.Errorf("failed to get stats: %w", err)
	}

	return &Stats{
		TotalPackets:   bpfStats.TotalPackets,
		AllowedPackets: bpfStats.AllowedPackets,
		BlockedPackets: bpfStats.BlockedPackets,
	}, nil
}

// Server provides HTTP API for firewall management
type Server struct {
	fw *XDPFirewall
	fm *FirewallManager
}

// NewServer creates a new firewall server
func NewServer(fw *XDPFirewall, fm *FirewallManager) *Server {
	return &Server{fw: fw, fm: fm}
}

// Start starts the HTTP server
func (s *Server) Start(ctx context.Context, addr string) error {
	mux := http.NewServeMux()

	// API routes
	mux.HandleFunc("/api/rules/whitelist", s.handleWhitelistRules)
	mux.HandleFunc("/api/rules/blacklist", s.handleBlacklistRules)
	mux.HandleFunc("/api/stats", s.handleStats)

	server := &http.Server{
		Addr:    addr,
		Handler: mux,
	}

	// Start server in goroutine
	errCh := make(chan error, 1)
	go func() {
		errCh <- server.ListenAndServe()
	}()

	// Wait for context cancellation or server error
	select {
	case <-ctx.Done():
		return server.Shutdown(context.Background())
	case err := <-errCh:
		return err
	}
}

func (s *Server) handleWhitelistRules(w http.ResponseWriter, r *http.Request) {
	// Implementation for whitelist rules API
	w.Header().Set("Content-Type", "application/json")

	switch r.Method {
	case http.MethodGet:
		// List rules
		rules, err := s.fw.ListWhitelistRules()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		// Return JSON response (simplified)
		fmt.Fprintf(w, `{"rules": %v}`, len(rules))

	case http.MethodPost:
		// Add rule (simplified - would need proper JSON parsing)
		w.WriteHeader(http.StatusCreated)
		fmt.Fprintf(w, `{"status": "rule added"}`)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleBlacklistRules(w http.ResponseWriter, r *http.Request) {
	// Implementation for blacklist rules API
	w.Header().Set("Content-Type", "application/json")

	switch r.Method {
	case http.MethodGet:
		// List rules
		rules, err := s.fw.ListBlacklistRules()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		// Return JSON response (simplified)
		fmt.Fprintf(w, `{"rules": %v}`, len(rules))

	case http.MethodPost:
		// Add rule (simplified - would need proper JSON parsing)
		w.WriteHeader(http.StatusCreated)
		fmt.Fprintf(w, `{"status": "rule added"}`)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleStats(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	stats, err := s.fw.GetStats()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"total": %d, "allowed": %d, "blocked": %d}`,
		stats.TotalPackets, stats.AllowedPackets, stats.BlockedPackets)
}

// TCFirewallManager manages TC-based firewall rules
type TCFirewallManager struct {
	pinPath string
	objects *firewall_tcObjects
}

// NewTCFirewallManager creates a new TC firewall manager
func NewTCFirewallManager(pinPath string) *TCFirewallManager {
	return &TCFirewallManager{
		pinPath: pinPath,
	}
}

// LoadPinnedMaps loads pinned BPF maps for TC firewall
func (m *TCFirewallManager) LoadPinnedMaps() error {
	// Remove memory limit for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		return fmt.Errorf("failed to remove memory limit: %v", err)
	}

	// Load objects from pinned maps
	spec, err := loadFirewall_tc()
	if err != nil {
		return fmt.Errorf("failed to load firewall_tc spec: %v", err)
	}

	// Load with pinned maps
	opts := ebpf.CollectionOptions{
		MapReplacements: map[string]*ebpf.Map{},
	}

	// Try to load pinned maps
	mapNames := []string{
		"tc_ingress_whitelist",
		"tc_ingress_blacklist",
		"tc_egress_whitelist",
		"tc_egress_blacklist",
		"tc_stats_map",
		"tc_ingress_whitelist_count",
		"tc_ingress_blacklist_count",
		"tc_egress_whitelist_count",
		"tc_egress_blacklist_count",
	}

	for _, mapName := range mapNames {
		pinnedMap, err := ebpf.LoadPinnedMap(fmt.Sprintf("%s/%s", m.pinPath, mapName), nil)
		if err != nil {
			return fmt.Errorf("failed to load pinned map %s: %v", mapName, err)
		}
		opts.MapReplacements[mapName] = pinnedMap
	}

	objects := &firewall_tcObjects{}
	if err := spec.LoadAndAssign(objects, &opts); err != nil {
		return fmt.Errorf("failed to load and assign objects: %v", err)
	}

	m.objects = objects
	return nil
}

// AddWhitelistRule adds a whitelist rule for specified direction
func (m *TCFirewallManager) AddWhitelistRule(rule TCRule, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return err
		}
	}

	// Convert to BPF rule structure
	tcRule := firewall_tcTcRule{
		IpStart:   rule.IPStart,
		IpEnd:     rule.IPEnd,
		Port:      rule.Port,
		Protocol:  rule.Protocol,
		RuleType:  TCRuleTypeWhitelist,
		Action:    TCActionAllow,
		Direction: direction,
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressWhitelist
		countMap = m.objects.TcIngressWhitelistCount
	} else {
		ruleMap = m.objects.TcEgressWhitelist
		countMap = m.objects.TcEgressWhitelistCount
	}

	// Get current rule count
	var ruleCount uint32
	key := uint32(0)
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		ruleCount = 0
	}

	// Add the rule at the next available index
	if err := ruleMap.Put(&ruleCount, &tcRule); err != nil {
		return fmt.Errorf("failed to add TC whitelist rule: %v", err)
	}

	// Update rule count
	ruleCount++
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update TC whitelist rule count: %v", err)
	}

	return nil
}

// AddBlacklistRule adds a blacklist rule for specified direction
func (m *TCFirewallManager) AddBlacklistRule(rule TCRule, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return err
		}
	}

	// Convert to BPF rule structure
	tcRule := firewall_tcTcRule{
		IpStart:   rule.IPStart,
		IpEnd:     rule.IPEnd,
		Port:      rule.Port,
		Protocol:  rule.Protocol,
		RuleType:  TCRuleTypeBlacklist,
		Action:    TCActionDeny,
		Direction: direction,
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressBlacklist
		countMap = m.objects.TcIngressBlacklistCount
	} else {
		ruleMap = m.objects.TcEgressBlacklist
		countMap = m.objects.TcEgressBlacklistCount
	}

	// Get current rule count
	var ruleCount uint32
	key := uint32(0)
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		ruleCount = 0
	}

	// Add the rule at the next available index
	if err := ruleMap.Put(&ruleCount, &tcRule); err != nil {
		return fmt.Errorf("failed to add TC blacklist rule: %v", err)
	}

	// Update rule count
	ruleCount++
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update TC blacklist rule count: %v", err)
	}

	return nil
}

// Legacy methods for backward compatibility
func (m *TCFirewallManager) AddIngressRule(rule TCRule) error {
	// Default to blacklist for backward compatibility
	rule.RuleType = TCRuleTypeBlacklist
	return m.AddBlacklistRule(rule, TCDirectionIngress)
}

func (m *TCFirewallManager) AddEgressRule(rule TCRule) error {
	// Default to blacklist for backward compatibility
	rule.RuleType = TCRuleTypeBlacklist
	return m.AddBlacklistRule(rule, TCDirectionEgress)
}

// RemoveWhitelistRule removes a whitelist rule by index
func (m *TCFirewallManager) RemoveWhitelistRule(index uint32, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return err
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressWhitelist
		countMap = m.objects.TcIngressWhitelistCount
	} else {
		ruleMap = m.objects.TcEgressWhitelist
		countMap = m.objects.TcEgressWhitelistCount
	}

	// Get current rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return fmt.Errorf("no whitelist rules found")
	}

	if index >= ruleCount {
		return fmt.Errorf("rule index %d out of range (0-%d)", index, ruleCount-1)
	}

	// Shift rules to fill the gap
	for i := index; i < ruleCount-1; i++ {
		var rule firewall_tcTcRule
		if err := ruleMap.Lookup(&[]uint32{i + 1}[0], &rule); err != nil {
			return fmt.Errorf("failed to read rule at index %d: %v", i+1, err)
		}
		if err := ruleMap.Put(&i, &rule); err != nil {
			return fmt.Errorf("failed to move rule from %d to %d: %v", i+1, i, err)
		}
	}

	// Update rule count
	ruleCount--
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update whitelist rule count: %v", err)
	}

	return nil
}

// RemoveBlacklistRule removes a blacklist rule by index
func (m *TCFirewallManager) RemoveBlacklistRule(index uint32, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return err
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressBlacklist
		countMap = m.objects.TcIngressBlacklistCount
	} else {
		ruleMap = m.objects.TcEgressBlacklist
		countMap = m.objects.TcEgressBlacklistCount
	}

	// Get current rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return fmt.Errorf("no blacklist rules found")
	}

	if index >= ruleCount {
		return fmt.Errorf("rule index %d out of range (0-%d)", index, ruleCount-1)
	}

	// Shift rules to fill the gap
	for i := index; i < ruleCount-1; i++ {
		var rule firewall_tcTcRule
		if err := ruleMap.Lookup(&[]uint32{i + 1}[0], &rule); err != nil {
			return fmt.Errorf("failed to read rule at index %d: %v", i+1, err)
		}
		if err := ruleMap.Put(&i, &rule); err != nil {
			return fmt.Errorf("failed to move rule from %d to %d: %v", i+1, i, err)
		}
	}

	// Update rule count
	ruleCount--
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update blacklist rule count: %v", err)
	}

	return nil
}

// Legacy remove methods for backward compatibility
func (m *TCFirewallManager) RemoveIngressRule(index uint32) error {
	// Try removing from blacklist first for backward compatibility
	return m.RemoveBlacklistRule(index, TCDirectionIngress)
}

func (m *TCFirewallManager) RemoveEgressRule(index uint32) error {
	// Try removing from blacklist first for backward compatibility
	return m.RemoveBlacklistRule(index, TCDirectionEgress)
}

// ListWhitelistRules lists all whitelist rules for specified direction
func (m *TCFirewallManager) ListWhitelistRules(direction uint8) ([]TCRule, error) {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return nil, err
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressWhitelist
		countMap = m.objects.TcIngressWhitelistCount
	} else {
		ruleMap = m.objects.TcEgressWhitelist
		countMap = m.objects.TcEgressWhitelistCount
	}

	// Get rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return []TCRule{}, nil // No rules found
	}

	rules := make([]TCRule, 0, ruleCount)
	for i := uint32(0); i < ruleCount; i++ {
		var tcRule firewall_tcTcRule
		if err := ruleMap.Lookup(&i, &tcRule); err != nil {
			continue // Skip missing rules
		}

		rule := TCRule{
			IPStart:   tcRule.IpStart,
			IPEnd:     tcRule.IpEnd,
			Port:      tcRule.Port,
			Protocol:  tcRule.Protocol,
			RuleType:  tcRule.RuleType,
			Action:    tcRule.Action,
			Direction: tcRule.Direction,
		}
		rules = append(rules, rule)
	}

	return rules, nil
}

// ListBlacklistRules lists all blacklist rules for specified direction
func (m *TCFirewallManager) ListBlacklistRules(direction uint8) ([]TCRule, error) {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return nil, err
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressBlacklist
		countMap = m.objects.TcIngressBlacklistCount
	} else {
		ruleMap = m.objects.TcEgressBlacklist
		countMap = m.objects.TcEgressBlacklistCount
	}

	// Get rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return []TCRule{}, nil // No rules found
	}

	rules := make([]TCRule, 0, ruleCount)
	for i := uint32(0); i < ruleCount; i++ {
		var tcRule firewall_tcTcRule
		if err := ruleMap.Lookup(&i, &tcRule); err != nil {
			continue // Skip missing rules
		}

		rule := TCRule{
			IPStart:   tcRule.IpStart,
			IPEnd:     tcRule.IpEnd,
			Port:      tcRule.Port,
			Protocol:  tcRule.Protocol,
			RuleType:  tcRule.RuleType,
			Action:    tcRule.Action,
			Direction: tcRule.Direction,
		}
		rules = append(rules, rule)
	}

	return rules, nil
}

// Legacy list methods for backward compatibility
func (m *TCFirewallManager) ListIngressRules() ([]TCRule, error) {
	// Return blacklist rules for backward compatibility
	return m.ListBlacklistRules(TCDirectionIngress)
}

func (m *TCFirewallManager) ListEgressRules() ([]TCRule, error) {
	// Return blacklist rules for backward compatibility
	return m.ListBlacklistRules(TCDirectionEgress)
}

// GetTCStats gets TC firewall statistics
func (m *TCFirewallManager) GetTCStats() (*TCStats, error) {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return nil, err
		}
	}

	var key uint32 = 0
	var stats firewall_tcFirewallTcStats
	if err := m.objects.TcStatsMap.Lookup(&key, &stats); err != nil {
		return &TCStats{}, nil // Return empty stats if not found
	}

	return &TCStats{
		TotalPackets:   stats.TotalPackets,
		AllowedPackets: stats.AllowedPackets,
		DeniedPackets:  stats.DeniedPackets,
		IngressPackets: stats.IngressPackets,
		EgressPackets:  stats.EgressPackets,
	}, nil
}

// Close closes the TC firewall manager
func (m *TCFirewallManager) Close() error {
	if m.objects != nil {
		return m.objects.Close()
	}
	return nil
}
