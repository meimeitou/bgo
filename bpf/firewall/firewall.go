//go:build !ignore_autogenerated

package firewall

import (
	"context"
	"encoding/binary"
	"fmt"
	"net"
	"net/http"
	"os"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
	"github.com/vishvananda/netlink"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type fw_rule -type fw_stats firewall firewall.c -- -I../../lib
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type tc_rule -type firewall_tc_stats firewall_tc firewall_tc.c -- -I../../lib

const (
	// MaxRules defines the maximum number of rules we can handle (using #pragma unroll)
	MaxRules = 100
	PinPath  = "/sys/fs/bpf/firewall"
)

// Protocol constants matching BPF code
const (
	ProtocolTCP  = 6
	ProtocolUDP  = 17
	ProtocolICMP = 1
	ProtocolAny  = 0
)

// Action constants
const (
	ActionBlock = 0
	ActionAllow = 1
)

// Config map keys
const (
	ConfigWhitelistEnabled = 0
	ConfigBlacklistEnabled = 1
	ConfigDefaultAction    = 2
	ConfigLvsEnabled       = 3
)

// TC firewall constants
const (
	TCRuleTypeWhitelist = 0
	TCRuleTypeBlacklist = 1
	TCDirectionIngress  = 0
	TCDirectionEgress   = 1
	TCActionAllow       = 0
	TCActionDeny        = 1
)

// Rule represents a firewall rule
type Rule struct {
	IPStart  net.IP `json:"ip_start"`
	IPEnd    net.IP `json:"ip_end"`
	Port     uint16 `json:"port"`
	Protocol uint8  `json:"protocol"`
	Action   uint8  `json:"action"`
}

// Stats represents firewall statistics
type Stats struct {
	TotalPackets   uint64 `json:"total_packets"`
	AllowedPackets uint64 `json:"allowed_packets"`
	BlockedPackets uint64 `json:"blocked_packets"`
}

// TCRule represents a TC firewall rule with whitelist/blacklist support
type TCRule struct {
	IPStart   uint32 `json:"ip_start"`
	IPEnd     uint32 `json:"ip_end"`
	Port      uint16 `json:"port"`
	Protocol  uint8  `json:"protocol"`  // 0=ANY, 1=ICMP, 6=TCP, 17=UDP
	RuleType  uint8  `json:"rule_type"` // 0=WHITELIST, 1=BLACKLIST
	Action    uint8  `json:"action"`    // 0=ALLOW, 1=DENY (mainly for default action)
	Direction uint8  `json:"direction"` // 0=INGRESS, 1=EGRESS
}

// TCStats represents TC firewall statistics
type TCStats struct {
	TotalPackets   uint64 `json:"total_packets"`
	AllowedPackets uint64 `json:"allowed_packets"`
	DeniedPackets  uint64 `json:"denied_packets"`
	IngressPackets uint64 `json:"ingress_packets"`
	EgressPackets  uint64 `json:"egress_packets"`
}

// XDPFirewall manages XDP firewall functionality
type XDPFirewall struct {
	objs    *firewallObjects
	link    link.Link
	iface   string
	pinPath string
	pinned  bool
}

// NewXDPFirewall creates a new XDP firewall instance
func NewXDPFirewall(iface string) (*XDPFirewall, error) {
	return NewXDPFirewallWithPin(iface, "")
}

// NewXDPFirewallWithPin creates a new XDP firewall instance with optional pinning
func NewXDPFirewallWithPin(iface, pinPath string) (*XDPFirewall, error) {
	// Remove memory limit for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memory limit: %w", err)
	}

	fw := &XDPFirewall{
		iface:   iface,
		pinPath: pinPath,
	}

	// Try to load from pinned maps first if pin path is provided
	if pinPath != "" {
		if err := fw.loadFromPinned(); err != nil {
			// If loading from pinned fails, create new
			if err := fw.loadNew(); err != nil {
				return nil, err
			}
		} else {
			fw.pinned = true
		}
	} else {
		if err := fw.loadNew(); err != nil {
			return nil, err
		}
	}

	return fw, nil
}

// loadNew loads a new eBPF program
func (fw *XDPFirewall) loadNew() error {
	var opts *ebpf.CollectionOptions
	if fw.pinPath != "" {
		// Create pin directory if it doesn't exist
		if err := os.MkdirAll(fw.pinPath, 0755); err != nil {
			return fmt.Errorf("failed to create pin directory %s: %w", fw.pinPath, err)
		}

		opts = &ebpf.CollectionOptions{
			Maps: ebpf.MapOptions{
				PinPath: fw.pinPath,
			},
		}
	}

	objs := &firewallObjects{}
	if err := loadFirewallObjects(objs, opts); err != nil {
		return fmt.Errorf("failed to load eBPF objects: %w", err)
	}

	fw.objs = objs

	// Initialize config with default values
	if err := fw.initializeConfig(); err != nil {
		return fmt.Errorf("failed to initialize config: %w", err)
	}

	return nil
}

// loadFromPinned loads from existing pinned maps
func (fw *XDPFirewall) loadFromPinned() error {
	if fw.pinPath == "" {
		return fmt.Errorf("pin path is required")
	}

	// Load pinned maps
	whitelistMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/whitelist_map", &ebpf.LoadPinOptions{})
	if err != nil {
		return fmt.Errorf("failed to load pinned whitelist map: %w", err)
	}

	blacklistMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/blacklist_map", &ebpf.LoadPinOptions{})
	if err != nil {
		whitelistMap.Close()
		return fmt.Errorf("failed to load pinned blacklist map: %w", err)
	}

	statsMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/stats_map", &ebpf.LoadPinOptions{})
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		return fmt.Errorf("failed to load pinned stats map: %w", err)
	}

	configMap, err := ebpf.LoadPinnedMap(fw.pinPath+"/config_map", &ebpf.LoadPinOptions{})
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		statsMap.Close()
		return fmt.Errorf("failed to load pinned config map: %w", err)
	}

	// Load the program (this won't be pinned, but we need it for attachment)
	spec, err := loadFirewall()
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		statsMap.Close()
		configMap.Close()
		return fmt.Errorf("failed to load program spec: %w", err)
	}

	prog, err := ebpf.NewProgram(spec.Programs["xdp_firewall"])
	if err != nil {
		whitelistMap.Close()
		blacklistMap.Close()
		statsMap.Close()
		configMap.Close()
		return fmt.Errorf("failed to create program: %w", err)
	}

	fw.objs = &firewallObjects{}
	fw.objs.XdpFirewallWithLvs = prog
	fw.objs.WhitelistMap = whitelistMap
	fw.objs.BlacklistMap = blacklistMap
	fw.objs.StatsMap = statsMap
	fw.objs.ConfigMap = configMap

	return nil
}

// initializeConfig sets up default configuration
func (fw *XDPFirewall) initializeConfig() error {
	// Set default values
	configs := map[uint32]uint32{
		ConfigWhitelistEnabled: 1, // Enable whitelist by default
		ConfigBlacklistEnabled: 1, // Enable blacklist by default
		ConfigDefaultAction:    1, // Default to PASS
	}

	for key, value := range configs {
		if err := fw.objs.ConfigMap.Put(key, value); err != nil {
			return fmt.Errorf("failed to set config %d: %w", key, err)
		}
	}

	// Initialize stats
	stats := firewallFwStats{}
	if err := fw.objs.StatsMap.Put(uint32(0), stats); err != nil {
		return fmt.Errorf("failed to initialize stats: %w", err)
	}

	return nil
}

// Attach attaches the XDP program to the network interface
func (fw *XDPFirewall) Attach() error {
	if fw.link != nil {
		return fmt.Errorf("firewall is already attached")
	}

	// Get interface index
	iface, err := net.InterfaceByName(fw.iface)
	if err != nil {
		return fmt.Errorf("failed to find interface %s: %w", fw.iface, err)
	}

	l, err := link.AttachXDP(link.XDPOptions{
		Program:   fw.objs.XdpFirewallWithLvs,
		Interface: iface.Index,
		Flags:     link.XDPGenericMode,
	})
	if err != nil {
		return fmt.Errorf("failed to attach XDP program: %w", err)
	}

	fw.link = l
	return nil
}

// Detach detaches the XDP program from the network interface
func (fw *XDPFirewall) Detach() error {
	if fw.link != nil {
		if err := fw.link.Close(); err != nil {
			return fmt.Errorf("failed to detach XDP program: %w", err)
		}
		fw.link = nil
	}
	return nil
}

// Close cleans up resources
func (fw *XDPFirewall) Close() error {
	if err := fw.Detach(); err != nil {
		return err
	}

	if fw.objs != nil {
		fw.objs.Close()
	}
	return nil
}

// AddWhitelistRule adds a rule to the whitelist
func (fw *XDPFirewall) AddWhitelistRule(rule Rule) error {
	return fw.addRule(&fw.objs.WhitelistMap, rule)
}

// AddBlacklistRule adds a rule to the blacklist
func (fw *XDPFirewall) AddBlacklistRule(rule Rule) error {
	return fw.addRule(&fw.objs.BlacklistMap, rule)
}

// addRule adds a rule to the specified map
func (fw *XDPFirewall) addRule(targetMap **ebpf.Map, rule Rule) error {
	// Find an empty slot
	for i := uint32(0); i < MaxRules; i++ {
		var existingRule firewallFwRule
		err := (*targetMap).Lookup(i, &existingRule)
		if err != nil || existingRule.IpStart == 0 {
			// Empty slot found
			bpfRule := firewallFwRule{
				IpStart:  IPToUint32(rule.IPStart),
				IpEnd:    IPToUint32(rule.IPEnd),
				Port:     rule.Port,
				Protocol: rule.Protocol,
				Action:   rule.Action,
			}
			return (*targetMap).Put(i, bpfRule)
		}
	}
	return fmt.Errorf("no available slots (max %d rules)", MaxRules)
}

// RemoveWhitelistRule removes a rule from the whitelist
func (fw *XDPFirewall) RemoveWhitelistRule(index uint32) error {
	return fw.removeRule(&fw.objs.WhitelistMap, index)
}

// RemoveBlacklistRule removes a rule from the blacklist
func (fw *XDPFirewall) RemoveBlacklistRule(index uint32) error {
	return fw.removeRule(&fw.objs.BlacklistMap, index)
}

// removeRule removes a rule from the specified map
func (fw *XDPFirewall) removeRule(targetMap **ebpf.Map, index uint32) error {
	if index >= MaxRules {
		return fmt.Errorf("index %d out of range (max %d)", index, MaxRules-1)
	}

	// Clear the rule by setting it to zero values
	emptyRule := firewallFwRule{}
	return (*targetMap).Put(index, emptyRule)
}

// ListWhitelistRules lists all whitelist rules
func (fw *XDPFirewall) ListWhitelistRules() ([]Rule, error) {
	return fw.listRules(&fw.objs.WhitelistMap)
}

// ListBlacklistRules lists all blacklist rules
func (fw *XDPFirewall) ListBlacklistRules() ([]Rule, error) {
	return fw.listRules(&fw.objs.BlacklistMap)
}

// listRules lists all rules from the specified map
func (fw *XDPFirewall) listRules(targetMap **ebpf.Map) ([]Rule, error) {
	var rules []Rule

	for i := uint32(0); i < MaxRules; i++ {
		var bpfRule firewallFwRule
		if err := (*targetMap).Lookup(i, &bpfRule); err != nil {
			continue
		}

		if bpfRule.IpStart != 0 {
			rule := Rule{
				IPStart:  Uint32ToIP(bpfRule.IpStart),
				IPEnd:    Uint32ToIP(bpfRule.IpEnd),
				Port:     bpfRule.Port,
				Protocol: bpfRule.Protocol,
				Action:   bpfRule.Action,
			}
			rules = append(rules, rule)
		}
	}

	return rules, nil
}

// GetStats returns current firewall statistics
func (fw *XDPFirewall) GetStats() (*Stats, error) {
	var bpfStats firewallFwStats
	if err := fw.objs.StatsMap.Lookup(uint32(0), &bpfStats); err != nil {
		return nil, fmt.Errorf("failed to get stats: %w", err)
	}

	return &Stats{
		TotalPackets:   bpfStats.TotalPackets,
		AllowedPackets: bpfStats.AllowedPackets,
		BlockedPackets: bpfStats.BlockedPackets,
	}, nil
}

// SetConfig sets a configuration value
func (fw *XDPFirewall) SetConfig(key, value uint32) error {
	return fw.objs.ConfigMap.Put(key, value)
}

// GetConfig gets a configuration value
func (fw *XDPFirewall) GetConfig(key uint32) (uint32, error) {
	var value uint32
	err := fw.objs.ConfigMap.Lookup(key, &value)
	return value, err
}

// IPToUint32 converts IP address to uint32 (network byte order)
func IPToUint32(ip net.IP) uint32 {
	if ip == nil {
		return 0
	}
	ip = ip.To4()
	if ip == nil {
		return 0
	}
	return binary.LittleEndian.Uint32(ip)
}

// Uint32ToIP converts uint32 to IP address (network byte order)
func Uint32ToIP(val uint32) net.IP {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, val)
	return ip
}

// ParseCIDR parses CIDR notation and returns start and end IP addresses
func ParseCIDR(cidr string) (net.IP, net.IP, error) {
	_, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		return nil, nil, err
	}

	startIP := ipNet.IP
	endIP := make(net.IP, len(startIP))
	copy(endIP, startIP)

	// Calculate end IP
	for i := 0; i < len(endIP); i++ {
		endIP[i] |= ^ipNet.Mask[i]
	}

	return startIP, endIP, nil
}

// FirewallManager provides CLI interface for managing pinned maps
type FirewallManager struct {
	pinPath string
}

// NewFirewallManager creates a new firewall manager for CLI operations
func NewFirewallManager(pinPath string) *FirewallManager {
	if pinPath == "" {
		pinPath = PinPath
	}
	return &FirewallManager{pinPath: pinPath}
}

// AddWhitelistRule adds a rule to the whitelist via pinned maps
func (fm *FirewallManager) AddWhitelistRule(rule Rule) error {
	mapPath := fmt.Sprintf("%s/whitelist_map", fm.pinPath)
	return fm.addRuleToMap(mapPath, rule)
}

// AddBlacklistRule adds a rule to the blacklist via pinned maps
func (fm *FirewallManager) AddBlacklistRule(rule Rule) error {
	mapPath := fmt.Sprintf("%s/blacklist_map", fm.pinPath)
	return fm.addRuleToMap(mapPath, rule)
}

// addRuleToMap adds a rule to the specified pinned map
func (fm *FirewallManager) addRuleToMap(mapPath string, rule Rule) error {
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return fmt.Errorf("failed to load pinned map %s: %w", mapPath, err)
	}
	defer m.Close()

	// Find an empty slot
	for i := uint32(0); i < MaxRules; i++ {
		var existingRule firewallFwRule
		err := m.Lookup(i, &existingRule)
		if err != nil || existingRule.IpStart == 0 {
			// Empty slot found
			bpfRule := firewallFwRule{
				IpStart:  IPToUint32(rule.IPStart),
				IpEnd:    IPToUint32(rule.IPEnd),
				Port:     rule.Port,
				Protocol: rule.Protocol,
				Action:   rule.Action,
			}
			return m.Put(i, bpfRule)
		}
	}
	return fmt.Errorf("no available slots (max %d rules)", MaxRules)
}

// RemoveWhitelistRule removes a rule from the whitelist
func (fm *FirewallManager) RemoveWhitelistRule(index uint32) error {
	mapPath := fmt.Sprintf("%s/whitelist_map", fm.pinPath)
	return fm.removeRuleFromMap(mapPath, index)
}

// RemoveBlacklistRule removes a rule from the blacklist
func (fm *FirewallManager) RemoveBlacklistRule(index uint32) error {
	mapPath := fmt.Sprintf("%s/blacklist_map", fm.pinPath)
	return fm.removeRuleFromMap(mapPath, index)
}

// removeRuleFromMap removes a rule from the specified pinned map
func (fm *FirewallManager) removeRuleFromMap(mapPath string, userIndex uint32) error {
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return fmt.Errorf("failed to load pinned map %s: %w", mapPath, err)
	}
	defer m.Close()

	// Find the actual BPF map index corresponding to the user-visible index
	var validRuleCount uint32 = 0
	var actualIndex uint32
	var found bool

	for i := uint32(0); i < MaxRules; i++ {
		var bpfRule firewallFwRule
		if err := m.Lookup(i, &bpfRule); err != nil {
			continue
		}

		if bpfRule.IpStart != 0 {
			if validRuleCount == userIndex {
				actualIndex = i
				found = true
				break
			}
			validRuleCount++
		}
	}

	if !found {
		return fmt.Errorf("rule at index %d not found", userIndex)
	}

	// Clear the rule by setting it to zero values
	emptyRule := firewallFwRule{}
	return m.Put(actualIndex, emptyRule)
}

// ListWhitelistRules lists all whitelist rules
func (fm *FirewallManager) ListWhitelistRules() ([]Rule, error) {
	mapPath := fmt.Sprintf("%s/whitelist_map", fm.pinPath)
	return fm.listRulesFromMap(mapPath)
}

// ListBlacklistRules lists all blacklist rules
func (fm *FirewallManager) ListBlacklistRules() ([]Rule, error) {
	mapPath := fmt.Sprintf("%s/blacklist_map", fm.pinPath)
	return fm.listRulesFromMap(mapPath)
}

// listRulesFromMap lists all rules from the specified pinned map
func (fm *FirewallManager) listRulesFromMap(mapPath string) ([]Rule, error) {
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to load pinned map %s: %w", mapPath, err)
	}
	defer m.Close()

	var rules []Rule
	for i := uint32(0); i < MaxRules; i++ {
		var bpfRule firewallFwRule
		if err := m.Lookup(i, &bpfRule); err != nil {
			continue
		}

		if bpfRule.IpStart != 0 {
			rule := Rule{
				IPStart:  Uint32ToIP(bpfRule.IpStart),
				IPEnd:    Uint32ToIP(bpfRule.IpEnd),
				Port:     bpfRule.Port,
				Protocol: bpfRule.Protocol,
				Action:   bpfRule.Action,
			}
			rules = append(rules, rule)
		}
	}

	return rules, nil
}

// GetStats returns current firewall statistics from pinned maps
func (fm *FirewallManager) GetStats() (*Stats, error) {
	mapPath := fmt.Sprintf("%s/stats_map", fm.pinPath)
	m, err := ebpf.LoadPinnedMap(mapPath, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to load pinned stats map: %w", err)
	}
	defer m.Close()

	var bpfStats firewallFwStats
	if err := m.Lookup(uint32(0), &bpfStats); err != nil {
		return nil, fmt.Errorf("failed to get stats: %w", err)
	}

	return &Stats{
		TotalPackets:   bpfStats.TotalPackets,
		AllowedPackets: bpfStats.AllowedPackets,
		BlockedPackets: bpfStats.BlockedPackets,
	}, nil
}

// Server provides HTTP API for firewall management
type Server struct {
	fw *XDPFirewall
	fm *FirewallManager
}

// NewServer creates a new firewall server
func NewServer(fw *XDPFirewall, fm *FirewallManager) *Server {
	return &Server{fw: fw, fm: fm}
}

// Start starts the HTTP server
func (s *Server) Start(ctx context.Context, addr string) error {
	mux := http.NewServeMux()

	// API routes
	mux.HandleFunc("/api/rules/whitelist", s.handleWhitelistRules)
	mux.HandleFunc("/api/rules/blacklist", s.handleBlacklistRules)
	mux.HandleFunc("/api/stats", s.handleStats)

	server := &http.Server{
		Addr:    addr,
		Handler: mux,
	}

	// Start server in goroutine
	errCh := make(chan error, 1)
	go func() {
		errCh <- server.ListenAndServe()
	}()

	// Wait for context cancellation or server error
	select {
	case <-ctx.Done():
		return server.Shutdown(context.Background())
	case err := <-errCh:
		return err
	}
}

func (s *Server) handleWhitelistRules(w http.ResponseWriter, r *http.Request) {
	// Implementation for whitelist rules API
	w.Header().Set("Content-Type", "application/json")

	switch r.Method {
	case http.MethodGet:
		// List rules
		rules, err := s.fw.ListWhitelistRules()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		// Return JSON response (simplified)
		fmt.Fprintf(w, `{"rules": %v}`, len(rules))

	case http.MethodPost:
		// Add rule (simplified - would need proper JSON parsing)
		w.WriteHeader(http.StatusCreated)
		fmt.Fprintf(w, `{"status": "rule added"}`)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleBlacklistRules(w http.ResponseWriter, r *http.Request) {
	// Implementation for blacklist rules API
	w.Header().Set("Content-Type", "application/json")

	switch r.Method {
	case http.MethodGet:
		// List rules
		rules, err := s.fw.ListBlacklistRules()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		// Return JSON response (simplified)
		fmt.Fprintf(w, `{"rules": %v}`, len(rules))

	case http.MethodPost:
		// Add rule (simplified - would need proper JSON parsing)
		w.WriteHeader(http.StatusCreated)
		fmt.Fprintf(w, `{"status": "rule added"}`)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleStats(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	stats, err := s.fw.GetStats()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"total": %d, "allowed": %d, "blocked": %d}`,
		stats.TotalPackets, stats.AllowedPackets, stats.BlockedPackets)
}

// TCFirewallManager manages TC-based firewall rules
type TCFirewallManager struct {
	pinPath     string
	objects     *firewall_tcObjects
	iface       string
	ingressLink link.Link
	egressLink  link.Link
}

// NewTCFirewallManager creates a new TC firewall manager
func NewTCFirewallManager(pinPath string) *TCFirewallManager {
	if pinPath == "" {
		pinPath = PinPath
	}
	return &TCFirewallManager{
		pinPath: pinPath,
	}
}

// NewTCFirewallManagerWithInterface creates a new TC firewall manager with interface
func NewTCFirewallManagerWithInterface(iface, pinPath string) *TCFirewallManager {
	if pinPath == "" {
		pinPath = PinPath
	}
	return &TCFirewallManager{
		pinPath: pinPath,
		iface:   iface,
	}
}

// LoadPinnedMaps loads pinned BPF maps for TC firewall
func (m *TCFirewallManager) LoadPinnedMaps() error {
	// Remove memory limit for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		return fmt.Errorf("failed to remove memory limit: %v", err)
	}

	// Try to load from pinned maps first
	if err := m.loadFromPinned(); err != nil {
		// If pinned maps don't exist, create new ones and pin them
		return m.createAndPinMaps()
	}

	return nil
}

// loadFromPinned attempts to load existing pinned maps
func (m *TCFirewallManager) loadFromPinned() error {
	spec, err := loadFirewall_tc()
	if err != nil {
		return fmt.Errorf("failed to load firewall_tc spec: %v", err)
	}

	// Load with pinned maps
	opts := ebpf.CollectionOptions{
		Maps: ebpf.MapOptions{
			PinPath: m.pinPath,
		},
	}

	objects := &firewall_tcObjects{}
	if err := spec.LoadAndAssign(objects, &opts); err != nil {
		return fmt.Errorf("failed to load and assign objects: %v", err)
	}

	m.objects = objects
	return nil
}

// createAndPinMaps creates new maps and pins them
func (m *TCFirewallManager) createAndPinMaps() error {
	// Create pin directory if it doesn't exist
	if err := os.MkdirAll(m.pinPath, 0755); err != nil {
		return fmt.Errorf("failed to create pin directory %s: %v", m.pinPath, err)
	}

	spec, err := loadFirewall_tc()
	if err != nil {
		return fmt.Errorf("failed to load firewall_tc spec: %v", err)
	}

	// Create new objects with pinning options
	opts := &ebpf.CollectionOptions{
		Maps: ebpf.MapOptions{
			PinPath: m.pinPath,
		},
	}

	objects := &firewall_tcObjects{}
	if err := spec.LoadAndAssign(objects, opts); err != nil {
		return fmt.Errorf("failed to load and assign new objects: %v", err)
	}

	// Initialize stats map
	key := uint32(0)
	stats := firewall_tcFirewallTcStats{}
	if err := objects.TcStatsMap.Put(&key, &stats); err != nil {
		return fmt.Errorf("failed to initialize stats: %v", err)
	}

	// Initialize rule count maps
	ruleCount := uint32(0)
	for _, countMap := range []*ebpf.Map{
		objects.TcIngressWhitelistCount,
		objects.TcIngressBlacklistCount,
		objects.TcEgressWhitelistCount,
		objects.TcEgressBlacklistCount,
	} {
		if err := countMap.Put(&key, &ruleCount); err != nil {
			return fmt.Errorf("failed to initialize rule count: %v", err)
		}
	}

	m.objects = objects
	return nil
}

// AddWhitelistRule adds a whitelist rule for specified direction
func (m *TCFirewallManager) AddWhitelistRule(rule TCRule, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	// Convert to BPF rule structure
	tcRule := firewall_tcTcRule{
		IpStart:   rule.IPStart,
		IpEnd:     rule.IPEnd,
		Port:      rule.Port,
		Protocol:  rule.Protocol,
		RuleType:  TCRuleTypeWhitelist,
		Action:    TCActionAllow,
		Direction: direction,
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressWhitelist
		countMap = m.objects.TcIngressWhitelistCount
	} else {
		ruleMap = m.objects.TcEgressWhitelist
		countMap = m.objects.TcEgressWhitelistCount
	}

	// Get current rule count
	var ruleCount uint32
	key := uint32(0)
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		ruleCount = 0
	}

	// Add the rule at the next available index
	if err := ruleMap.Put(&ruleCount, &tcRule); err != nil {
		return fmt.Errorf("failed to add TC whitelist rule: %v", err)
	}

	// Update rule count
	ruleCount++
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update TC whitelist rule count: %v", err)
	}

	return nil
}

// AddBlacklistRule adds a blacklist rule for specified direction
func (m *TCFirewallManager) AddBlacklistRule(rule TCRule, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	// Convert to BPF rule structure
	tcRule := firewall_tcTcRule{
		IpStart:   rule.IPStart,
		IpEnd:     rule.IPEnd,
		Port:      rule.Port,
		Protocol:  rule.Protocol,
		RuleType:  TCRuleTypeBlacklist,
		Action:    TCActionDeny,
		Direction: direction,
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressBlacklist
		countMap = m.objects.TcIngressBlacklistCount
	} else {
		ruleMap = m.objects.TcEgressBlacklist
		countMap = m.objects.TcEgressBlacklistCount
	}

	// Get current rule count
	var ruleCount uint32
	key := uint32(0)
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		ruleCount = 0
	}

	// Add the rule at the next available index
	if err := ruleMap.Put(&ruleCount, &tcRule); err != nil {
		return fmt.Errorf("failed to add TC blacklist rule: %v", err)
	}

	// Update rule count
	ruleCount++
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update TC blacklist rule count: %v", err)
	}

	return nil
}

// Legacy methods for backward compatibility
func (m *TCFirewallManager) AddIngressRule(rule TCRule) error {
	// Default to blacklist for backward compatibility
	rule.RuleType = TCRuleTypeBlacklist
	return m.AddBlacklistRule(rule, TCDirectionIngress)
}

func (m *TCFirewallManager) AddEgressRule(rule TCRule) error {
	// Default to blacklist for backward compatibility
	rule.RuleType = TCRuleTypeBlacklist
	return m.AddBlacklistRule(rule, TCDirectionEgress)
}

// RemoveWhitelistRule removes a whitelist rule by index
func (m *TCFirewallManager) RemoveWhitelistRule(index uint32, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressWhitelist
		countMap = m.objects.TcIngressWhitelistCount
	} else {
		ruleMap = m.objects.TcEgressWhitelist
		countMap = m.objects.TcEgressWhitelistCount
	}

	// Get current rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return fmt.Errorf("no whitelist rules found")
	}

	if index >= ruleCount {
		return fmt.Errorf("rule index %d out of range (0-%d)", index, ruleCount-1)
	}

	// Shift rules to fill the gap
	for i := index; i < ruleCount-1; i++ {
		var rule firewall_tcTcRule
		if err := ruleMap.Lookup(&[]uint32{i + 1}[0], &rule); err != nil {
			return fmt.Errorf("failed to read rule at index %d: %v", i+1, err)
		}
		if err := ruleMap.Put(&i, &rule); err != nil {
			return fmt.Errorf("failed to move rule from %d to %d: %v", i+1, i, err)
		}
	}

	// Update rule count
	ruleCount--
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update whitelist rule count: %v", err)
	}

	return nil
}

// RemoveBlacklistRule removes a blacklist rule by index
func (m *TCFirewallManager) RemoveBlacklistRule(index uint32, direction uint8) error {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressBlacklist
		countMap = m.objects.TcIngressBlacklistCount
	} else {
		ruleMap = m.objects.TcEgressBlacklist
		countMap = m.objects.TcEgressBlacklistCount
	}

	// Get current rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return fmt.Errorf("no blacklist rules found")
	}

	if index >= ruleCount {
		return fmt.Errorf("rule index %d out of range (0-%d)", index, ruleCount-1)
	}

	// Shift rules to fill the gap
	for i := index; i < ruleCount-1; i++ {
		var rule firewall_tcTcRule
		if err := ruleMap.Lookup(&[]uint32{i + 1}[0], &rule); err != nil {
			return fmt.Errorf("failed to read rule at index %d: %v", i+1, err)
		}
		if err := ruleMap.Put(&i, &rule); err != nil {
			return fmt.Errorf("failed to move rule from %d to %d: %v", i+1, i, err)
		}
	}

	// Update rule count
	ruleCount--
	if err := countMap.Put(&key, &ruleCount); err != nil {
		return fmt.Errorf("failed to update blacklist rule count: %v", err)
	}

	return nil
}

// Legacy remove methods for backward compatibility
func (m *TCFirewallManager) RemoveIngressRule(index uint32) error {
	// Try removing from blacklist first for backward compatibility
	return m.RemoveBlacklistRule(index, TCDirectionIngress)
}

func (m *TCFirewallManager) RemoveEgressRule(index uint32) error {
	// Try removing from blacklist first for backward compatibility
	return m.RemoveBlacklistRule(index, TCDirectionEgress)
}

// ListWhitelistRules lists all whitelist rules for specified direction
func (m *TCFirewallManager) ListWhitelistRules(direction uint8) ([]TCRule, error) {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return nil, fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressWhitelist
		countMap = m.objects.TcIngressWhitelistCount
	} else {
		ruleMap = m.objects.TcEgressWhitelist
		countMap = m.objects.TcEgressWhitelistCount
	}

	// Get rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return []TCRule{}, nil // No rules found
	}

	rules := make([]TCRule, 0, ruleCount)
	for i := uint32(0); i < ruleCount; i++ {
		var tcRule firewall_tcTcRule
		if err := ruleMap.Lookup(&i, &tcRule); err != nil {
			continue // Skip missing rules
		}

		rule := TCRule{
			IPStart:   tcRule.IpStart,
			IPEnd:     tcRule.IpEnd,
			Port:      tcRule.Port,
			Protocol:  tcRule.Protocol,
			RuleType:  tcRule.RuleType,
			Action:    tcRule.Action,
			Direction: tcRule.Direction,
		}
		rules = append(rules, rule)
	}

	return rules, nil
}

// ListBlacklistRules lists all blacklist rules for specified direction
func (m *TCFirewallManager) ListBlacklistRules(direction uint8) ([]TCRule, error) {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return nil, fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	var ruleMap *ebpf.Map
	var countMap *ebpf.Map

	// Select appropriate maps based on direction
	if direction == TCDirectionIngress {
		ruleMap = m.objects.TcIngressBlacklist
		countMap = m.objects.TcIngressBlacklistCount
	} else {
		ruleMap = m.objects.TcEgressBlacklist
		countMap = m.objects.TcEgressBlacklistCount
	}

	// Get rule count
	var key uint32 = 0
	var ruleCount uint32
	if err := countMap.Lookup(&key, &ruleCount); err != nil {
		return []TCRule{}, nil // No rules found
	}

	rules := make([]TCRule, 0, ruleCount)
	for i := uint32(0); i < ruleCount; i++ {
		var tcRule firewall_tcTcRule
		if err := ruleMap.Lookup(&i, &tcRule); err != nil {
			continue // Skip missing rules
		}

		rule := TCRule{
			IPStart:   tcRule.IpStart,
			IPEnd:     tcRule.IpEnd,
			Port:      tcRule.Port,
			Protocol:  tcRule.Protocol,
			RuleType:  tcRule.RuleType,
			Action:    tcRule.Action,
			Direction: tcRule.Direction,
		}
		rules = append(rules, rule)
	}

	return rules, nil
}

// Legacy list methods for backward compatibility
func (m *TCFirewallManager) ListIngressRules() ([]TCRule, error) {
	// Return blacklist rules for backward compatibility
	return m.ListBlacklistRules(TCDirectionIngress)
}

func (m *TCFirewallManager) ListEgressRules() ([]TCRule, error) {
	// Return blacklist rules for backward compatibility
	return m.ListBlacklistRules(TCDirectionEgress)
}

// GetTCStats gets TC firewall statistics
func (m *TCFirewallManager) GetTCStats() (*TCStats, error) {
	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return nil, fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	var key uint32 = 0
	var stats firewall_tcFirewallTcStats
	if err := m.objects.TcStatsMap.Lookup(&key, &stats); err != nil {
		return &TCStats{}, nil // Return empty stats if not found
	}

	return &TCStats{
		TotalPackets:   stats.TotalPackets,
		AllowedPackets: stats.AllowedPackets,
		DeniedPackets:  stats.DeniedPackets,
		IngressPackets: stats.IngressPackets,
		EgressPackets:  stats.EgressPackets,
	}, nil
}

// Close closes the TC firewall manager and detaches programs if attached
func (m *TCFirewallManager) Close() error {
	var errors []error

	// Try to detach programs if interface is set
	if m.iface != "" {
		// Always try to detach, regardless of current status
		// This is more robust during cleanup
		if err := m.DetachPrograms(); err != nil {
			// Log the error but don't fail the close operation
			fmt.Printf("Warning: failed to detach TC programs during close: %v\n", err)
			errors = append(errors, err)
		}
	}

	// Close the BPF objects
	if m.objects != nil {
		if err := m.objects.Close(); err != nil {
			fmt.Printf("Warning: failed to close TC BPF objects: %v\n", err)
			errors = append(errors, err)
		}
	}

	// For cleanup operations, we prefer to complete as much as possible
	// rather than failing early, so we return nil unless all operations failed
	if len(errors) > 0 {
		fmt.Printf("TC firewall cleanup completed with %d warnings\n", len(errors))
	}

	return nil
}

// AttachPrograms attaches TC programs to the interface for ingress and egress traffic
func (m *TCFirewallManager) AttachPrograms() error {
	if m.iface == "" {
		return fmt.Errorf("interface name not specified")
	}

	if m.objects == nil {
		if err := m.LoadPinnedMaps(); err != nil {
			return fmt.Errorf("failed to initialize maps: %v", err)
		}
	}

	// Get the network interface
	iface, err := netlink.LinkByName(m.iface)
	if err != nil {
		return fmt.Errorf("failed to get interface %s: %v", m.iface, err)
	}

	// Clean up any existing filters first to avoid conflicts
	fmt.Printf("Cleaning up existing TC filters on interface %s...\n", m.iface)
	m.DetachPrograms() // Ignore errors during cleanup

	// Create qdisc if it doesn't exist
	qdiscs, err := netlink.QdiscList(iface)
	if err != nil {
		return fmt.Errorf("failed to list qdiscs: %v", err)
	}

	hasClsact := false
	for _, qdisc := range qdiscs {
		if qdisc.Type() == "clsact" {
			hasClsact = true
			break
		}
	}

	if !hasClsact {
		qdisc := &netlink.GenericQdisc{
			QdiscAttrs: netlink.QdiscAttrs{
				LinkIndex: iface.Attrs().Index,
				Handle:    netlink.MakeHandle(0xffff, 0),
				Parent:    netlink.HANDLE_CLSACT,
			},
			QdiscType: "clsact",
		}

		if err := netlink.QdiscAdd(qdisc); err != nil {
			return fmt.Errorf("failed to add clsact qdisc: %v", err)
		}
		fmt.Printf("Added clsact qdisc to interface %s\n", m.iface)
	}

	// Attach ingress program
	ingressFilter := &netlink.BpfFilter{
		FilterAttrs: netlink.FilterAttrs{
			LinkIndex: iface.Attrs().Index,
			Parent:    netlink.HANDLE_MIN_INGRESS,
			Handle:    1,
			Protocol:  0x0003, // ETH_P_ALL
		},
		Fd:           m.objects.TcIngressFilter.FD(),
		Name:         "tc_ingress_firewall",
		DirectAction: true,
	}

	if err := netlink.FilterAdd(ingressFilter); err != nil {
		return fmt.Errorf("failed to attach TC ingress program: %v", err)
	}
	fmt.Printf("Attached TC ingress filter to interface %s\n", m.iface)

	// Attach egress program
	egressFilter := &netlink.BpfFilter{
		FilterAttrs: netlink.FilterAttrs{
			LinkIndex: iface.Attrs().Index,
			Parent:    netlink.HANDLE_MIN_EGRESS,
			Handle:    1,
			Protocol:  0x0003, // ETH_P_ALL
		},
		Fd:           m.objects.TcEgressFilter.FD(),
		Name:         "tc_egress_firewall",
		DirectAction: true,
	}

	if err := netlink.FilterAdd(egressFilter); err != nil {
		// Clean up ingress filter if egress fails
		fmt.Printf("Failed to attach egress filter, cleaning up ingress filter...\n")
		netlink.FilterDel(ingressFilter)
		return fmt.Errorf("failed to attach TC egress program: %v", err)
	}
	fmt.Printf("Attached TC egress filter to interface %s\n", m.iface)

	fmt.Printf("TC firewall programs successfully attached to interface %s\n", m.iface)
	return nil
}

// DetachPrograms detaches TC programs from the interface
func (m *TCFirewallManager) DetachPrograms() error {
	if m.iface == "" {
		return fmt.Errorf("interface name not specified")
	}

	// Get the network interface
	iface, err := netlink.LinkByName(m.iface)
	if err != nil {
		return fmt.Errorf("failed to get interface %s: %v", m.iface, err)
	}

	var errors []error

	// Remove ingress filters
	if err := m.removeFiltersForDirection(iface, netlink.HANDLE_MIN_INGRESS, "ingress"); err != nil {
		errors = append(errors, err)
	}

	// Remove egress filters
	if err := m.removeFiltersForDirection(iface, netlink.HANDLE_MIN_EGRESS, "egress"); err != nil {
		errors = append(errors, err)
	}

	if len(errors) == 0 {
		fmt.Printf("TC firewall programs detached from interface %s\n", m.iface)
	} else {
		fmt.Printf("TC firewall programs partially detached from interface %s with %d errors\n", m.iface, len(errors))
	}

	// Don't return errors for cleanup operations - just log them
	return nil
}

// removeFiltersForDirection removes all BPF filters for a specific direction
func (m *TCFirewallManager) removeFiltersForDirection(iface netlink.Link, parent uint32, direction string) error {
	// List all filters for this direction
	filters, err := netlink.FilterList(iface, parent)
	if err != nil {
		fmt.Printf("Warning: failed to list %s filters: %v\n", direction, err)
		return err
	}

	var errors []error
	removedCount := 0

	for _, filter := range filters {
		if bpfFilter, ok := filter.(*netlink.BpfFilter); ok {
			// Check if this is one of our firewall filters
			if bpfFilter.Name == fmt.Sprintf("tc_%s_firewall", direction) {
				if err := netlink.FilterDel(filter); err != nil {
					fmt.Printf("Warning: failed to remove TC %s filter (handle %d): %v\n", direction, bpfFilter.Handle, err)
					errors = append(errors, err)
				} else {
					removedCount++
					fmt.Printf("Removed TC %s filter (handle %d)\n", direction, bpfFilter.Handle)
				}
			}
		}
	}

	if removedCount == 0 && len(errors) == 0 {
		fmt.Printf("No TC %s filters found to remove\n", direction)
	}

	if len(errors) > 0 {
		return fmt.Errorf("failed to remove %d %s filters", len(errors), direction)
	}

	return nil
}

// IsAttached checks if TC programs are attached to the interface
func (m *TCFirewallManager) IsAttached() (bool, error) {
	if m.iface == "" {
		return false, fmt.Errorf("interface name not specified")
	}

	// Get the network interface
	iface, err := netlink.LinkByName(m.iface)
	if err != nil {
		return false, fmt.Errorf("failed to get interface %s: %v", m.iface, err)
	}

	// Check for ingress filters
	hasIngress := m.hasFirewallFilter(iface, netlink.HANDLE_MIN_INGRESS, "tc_ingress_firewall")

	// Check for egress filters
	hasEgress := m.hasFirewallFilter(iface, netlink.HANDLE_MIN_EGRESS, "tc_egress_firewall")

	return hasIngress && hasEgress, nil
}

// hasFirewallFilter checks if our firewall filter exists for a specific direction
func (m *TCFirewallManager) hasFirewallFilter(iface netlink.Link, parent uint32, filterName string) bool {
	filters, err := netlink.FilterList(iface, parent)
	if err != nil {
		return false
	}

	for _, filter := range filters {
		if bpfFilter, ok := filter.(*netlink.BpfFilter); ok && bpfFilter.Name == filterName {
			return true
		}
	}
	return false
}

// SetInterface sets the interface name for TC program attachment
func (m *TCFirewallManager) SetInterface(iface string) {
	m.iface = iface
}

// GetInterface returns the current interface name
func (m *TCFirewallManager) GetInterface() string {
	return m.iface
}
