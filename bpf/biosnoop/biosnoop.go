//go:build !ignore_autogenerated

package biosnoop

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/rlimit"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go biosnoop biosnoop.c -- -I../../lib

// BioEvent represents a single block I/O event
type BioEvent struct {
	PID    uint32 `json:"pid"`
	Dev    uint32 `json:"dev"`
	RWFlag uint64 `json:"rwflag"`
	Delta  uint64 `json:"delta"`  // I/O latency in nanoseconds
	QDelta uint64 `json:"qdelta"` // queue time in nanoseconds
	Sector uint64 `json:"sector"`
	Len    uint64 `json:"len"`
	TS     uint64 `json:"ts"`   // timestamp in microseconds
	Name   string `json:"name"` // process name
}

// BioSnoop manages the biosnoop BPF program
type BioSnoop struct {
	objs   *biosnoopObjects
	links  []link.Link
	reader *perf.Reader
}

// New creates a new BioSnoop instance
func New() (*BioSnoop, error) {
	// Remove memory limit for eBPF
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock: %w", err)
	}

	// Load pre-compiled programs and maps into kernel
	objs := biosnoopObjects{}
	if err := loadBiosnoopObjects(&objs, nil); err != nil {
		return nil, fmt.Errorf("failed to load eBPF objects: %w", err)
	}

	return &BioSnoop{
		objs: &objs,
	}, nil
}

// Start attaches the BPF programs and starts monitoring
func (b *BioSnoop) Start() error {
	// Attach tracepoints
	links := make([]link.Link, 0, 2)

	// Attach to block_rq_issue tracepoint
	l1, err := link.Tracepoint("block", "block_rq_issue", b.objs.TraceBlockRqIssue, nil)
	if err != nil {
		return fmt.Errorf("failed to attach tracepoint block:block_rq_issue: %w", err)
	}
	links = append(links, l1)

	// Attach to block_rq_complete tracepoint
	l2, err := link.Tracepoint("block", "block_rq_complete", b.objs.TraceBlockRqComplete, nil)
	if err != nil {
		return fmt.Errorf("failed to attach tracepoint block:block_rq_complete: %w", err)
	}
	links = append(links, l2)

	b.links = links

	// Open perf event reader
	reader, err := perf.NewReader(b.objs.Events, os.Getpagesize())
	if err != nil {
		return fmt.Errorf("failed to create perf reader: %w", err)
	}
	b.reader = reader

	return nil
}

// Close cleans up resources
func (b *BioSnoop) Close() error {
	var errs []error

	if b.reader != nil {
		if err := b.reader.Close(); err != nil {
			errs = append(errs, err)
		}
	}

	for _, l := range b.links {
		if err := l.Close(); err != nil {
			errs = append(errs, err)
		}
	}

	if b.objs != nil {
		b.objs.Close()
	}

	if len(errs) > 0 {
		return fmt.Errorf("cleanup errors: %v", errs)
	}
	return nil
}

// bioEventRaw represents the raw event data structure from BPF
type bioEventRaw struct {
	PID    uint32
	Dev    uint32
	RWFlag uint64
	Delta  uint64
	QDelta uint64
	Sector uint64
	Len    uint64
	TS     uint64
	Name   [16]byte
}

// parseBioEvent parses raw event data into BioEvent struct
func parseBioEvent(data []byte) (*BioEvent, error) {
	if len(data) < int(binary.Size(bioEventRaw{})) {
		return nil, fmt.Errorf("data too short: %d bytes", len(data))
	}

	var rawEvent bioEventRaw
	if err := binary.Read(bytes.NewReader(data), binary.LittleEndian, &rawEvent); err != nil {
		return nil, fmt.Errorf("failed to parse event: %w", err)
	}

	// Convert C string to Go string
	nameBytes := rawEvent.Name[:]
	nameStr := string(nameBytes[:cStringLen(nameBytes)])

	return &BioEvent{
		PID:    rawEvent.PID,
		Dev:    rawEvent.Dev,
		RWFlag: rawEvent.RWFlag,
		Delta:  rawEvent.Delta,
		QDelta: rawEvent.QDelta,
		Sector: rawEvent.Sector,
		Len:    rawEvent.Len,
		TS:     rawEvent.TS,
		Name:   nameStr,
	}, nil
}

// cStringLen returns the length of a null-terminated C string
func cStringLen(b []byte) int {
	for i, v := range b {
		if v == 0 {
			return i
		}
	}
	return len(b)
}

// getDiskName converts device ID to disk name
func getDiskName(dev uint32) string {
	major := dev >> 20
	minor := dev & ((1 << 20) - 1)

	// Try to read from /proc/diskstats
	file, err := os.Open("/proc/diskstats")
	if err != nil {
		return fmt.Sprintf("%d,%d", major, minor)
	}
	defer file.Close()

	var line string
	for {
		var maj, min uint32
		var name string
		n, err := fmt.Fscanf(file, "%d %d %s", &maj, &min, &name)
		if err != nil || n != 3 {
			break
		}
		if maj == major && min == minor {
			return name
		}
		// Skip rest of line
		fmt.Fscanln(file, &line)
	}

	return fmt.Sprintf("%d,%d", major, minor)
}

// formatDuration formats nanoseconds to human readable duration
func formatDuration(ns uint64) string {
	if ns < 1000 {
		return fmt.Sprintf("%dns", ns)
	} else if ns < 1000000 {
		return fmt.Sprintf("%.2fÎ¼s", float64(ns)/1000)
	} else if ns < 1000000000 {
		return fmt.Sprintf("%.2fms", float64(ns)/1000000)
	} else {
		return fmt.Sprintf("%.2fs", float64(ns)/1000000000)
	}
}

// Monitor starts monitoring block I/O and prints events
func (b *BioSnoop) Monitor(ctx context.Context, showQueue bool) error {
	var startTime uint64

	// Print header
	fmt.Printf("%-11s %-14s %-7s %-9s %-1s %-10s %-7s",
		"TIME(s)", "COMM", "PID", "DISK", "T", "SECTOR", "BYTES")
	if showQueue {
		fmt.Printf(" %7s", "QUE(ms)")
	}
	fmt.Printf(" %7s\n", "LAT(ms)")

	for {
		select {
		case <-ctx.Done():
			return nil
		default:
		}

		record, err := b.reader.Read()
		if err != nil {
			if err == perf.ErrClosed {
				return nil
			}
			log.Printf("Error reading perf event: %v", err)
			continue
		}

		if record.LostSamples != 0 {
			log.Printf("Lost %d samples", record.LostSamples)
			continue
		}

		event, err := parseBioEvent(record.RawSample)
		if err != nil {
			log.Printf("Error parsing event: %v", err)
			continue
		}

		// Set start time from first event
		if startTime == 0 {
			startTime = event.TS
		}

		// Calculate relative time in seconds
		relTime := float64(event.TS-startTime) / 1000000

		// Get disk name
		diskName := getDiskName(event.Dev)

		// Determine read/write
		rwFlag := "R"
		if event.RWFlag == 1 {
			rwFlag = "W"
		}

		// Format output
		fmt.Printf("%-11.6f %-14.14s %-7d %-9s %-1s %-10d %-7d",
			relTime, event.Name, event.PID, diskName, rwFlag, event.Sector, event.Len)

		if showQueue {
			queueMs := float64(event.QDelta) / 1000000
			fmt.Printf(" %7.2f", queueMs)
		}

		latencyMs := float64(event.Delta) / 1000000
		fmt.Printf(" %7.2f\n", latencyMs)
	}
}

// Run is the main entry point for biosnoop
func Run(showQueue bool) {
	biosnoop, err := New()
	if err != nil {
		log.Fatalf("Failed to create biosnoop: %v", err)
	}
	defer biosnoop.Close()

	if err := biosnoop.Start(); err != nil {
		log.Fatalf("Failed to start biosnoop: %v", err)
	}

	fmt.Println("Tracing block device I/O... Hit Ctrl-C to end.")

	// Set up signal handling
	ctx, cancel := context.WithCancel(context.Background())
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-c
		fmt.Println("\nExiting...")
		cancel()
	}()

	if err := biosnoop.Monitor(ctx, showQueue); err != nil {
		log.Fatalf("Monitor error: %v", err)
	}
}
