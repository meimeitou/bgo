//go:build !ignore_autogenerated

package filterdns

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type dns_stats filterdns filterdns.c -- -I../../lib

// Stats 统计信息
type Stats struct {
	TotalPackets   uint64 `json:"total_packets"`
	DNSPackets     uint64 `json:"dns_packets"`
	DroppedPackets uint64 `json:"dropped_packets"`
}

// FilterDNS DNS过滤器
type FilterDNS struct {
	objs    *filterdnsObjects
	xdpLink link.Link
	iface   string
}

// New 创建新的DNS过滤器
func New(interfaceName string) (*FilterDNS, error) {
	// 移除内存限制
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock limit: %w", err)
	}

	// 加载BPF程序
	objs := &filterdnsObjects{}
	if err := loadFilterdnsObjects(objs, nil); err != nil {
		return nil, fmt.Errorf("failed to load BPF objects: %w", err)
	}

	// 获取网卡索引
	iface, err := getInterfaceIndex(interfaceName)
	if err != nil {
		objs.Close()
		return nil, fmt.Errorf("failed to get interface index: %w", err)
	}

	// 附加XDP程序到网卡
	xdpLink, err := link.AttachXDP(link.XDPOptions{
		Program:   objs.XdpFilterDns,
		Interface: iface,
		Flags:     link.XDPGenericMode,
	})
	if err != nil {
		objs.Close()
		return nil, fmt.Errorf("failed to attach XDP program: %w", err)
	}

	fmt.Printf("XDP filter-dns attached to interface %s\n", interfaceName)
	fmt.Println("Only DNS traffic (port 53) will pass, all other traffic will be dropped")

	return &FilterDNS{
		objs:    objs,
		xdpLink: xdpLink,
		iface:   interfaceName,
	}, nil
}

// GetStats 获取统计信息
func (f *FilterDNS) GetStats() (*Stats, error) {
	var stats filterdnsDnsStats
	key := uint32(0)

	if err := f.objs.StatsMap.Lookup(key, &stats); err != nil {
		return nil, fmt.Errorf("failed to lookup stats: %w", err)
	}

	return &Stats{
		TotalPackets:   stats.TotalPackets,
		DNSPackets:     stats.DnsPackets,
		DroppedPackets: stats.DroppedPackets,
	}, nil
}

// Close 关闭并清理
func (f *FilterDNS) Close() error {
	fmt.Printf("Detaching XDP program from interface %s...\n", f.iface)

	if f.xdpLink != nil {
		if err := f.xdpLink.Close(); err != nil {
			return fmt.Errorf("failed to close XDP link: %w", err)
		}
	}

	if f.objs != nil {
		if err := f.objs.Close(); err != nil {
			return fmt.Errorf("failed to close BPF objects: %w", err)
		}
	}

	fmt.Println("XDP program detached successfully")
	return nil
}

// Run 运行DNS过滤服务
func (f *FilterDNS) Run() error {
	// 监听退出信号
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	fmt.Println("Filter-DNS service running. Press Ctrl+C to stop.")

	// 等待退出信号
	<-sigChan

	return f.Close()
}

// getInterfaceIndex 获取网卡索引
func getInterfaceIndex(name string) (int, error) {
	iface, err := os.ReadFile(fmt.Sprintf("/sys/class/net/%s/ifindex", name))
	if err != nil {
		return 0, fmt.Errorf("interface %s not found: %w", name, err)
	}

	var index int
	_, err = fmt.Sscanf(string(iface), "%d", &index)
	if err != nil {
		return 0, fmt.Errorf("failed to parse interface index: %w", err)
	}

	return index, nil
}
