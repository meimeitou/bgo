//go:build !ignore_autogenerated

package filterdns

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"net"
	"os"
	"os/signal"
	"runtime"
	"strings"
	"syscall"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type dns_stats -type filter_config -type ipv6_addr filterdns filterdns.c -- -I../../lib -I/usr/include/x86_64-linux-gnu

const (
	ListModeDisabled  = 0 // 不启用黑白名单
	ListModeWhitelist = 1 // 白名单模式
	ListModeBlacklist = 2 // 黑名单模式
)

// Stats 统计信息
type Stats struct {
	TotalPackets     uint64 `json:"total_packets"`
	DNSPackets       uint64 `json:"dns_packets"`
	DroppedPackets   uint64 `json:"dropped_packets"`
	WhitelistAllowed uint64 `json:"whitelist_allowed"`
	WhitelistDropped uint64 `json:"whitelist_dropped"`
	BlacklistDropped uint64 `json:"blacklist_dropped"`
}

// FilterDNS DNS过滤器
type FilterDNS struct {
	objs    *filterdnsObjects
	xdpLink link.Link
	iface   string
}

// New 创建新的DNS过滤器
func New(interfaceName string, whitelistFile string, blacklistFile string) (*FilterDNS, error) {
	// 移除内存限制
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock limit: %w", err)
	}

	// 加载BPF程序
	objs := &filterdnsObjects{}
	if err := loadFilterdnsObjects(objs, nil); err != nil {
		return nil, fmt.Errorf("failed to load BPF objects: %w", err)
	}

	// 设置黑白名单模式
	listMode := ListModeDisabled
	if whitelistFile != "" {
		listMode = ListModeWhitelist
		if err := loadIPList(objs, whitelistFile, true); err != nil {
			objs.Close()
			return nil, fmt.Errorf("failed to load whitelist: %w", err)
		}
		fmt.Printf("Whitelist loaded from %s\n", whitelistFile)
	} else if blacklistFile != "" {
		listMode = ListModeBlacklist
		if err := loadIPList(objs, blacklistFile, false); err != nil {
			objs.Close()
			return nil, fmt.Errorf("failed to load blacklist: %w", err)
		}
		fmt.Printf("Blacklist loaded from %s\n", blacklistFile)
	}

	// 更新配置 - Per-CPU map 需要为每个 CPU 提供相同的配置
	configKey := uint32(0)
	config := filterdnsFilterConfig{ListMode: uint32(listMode)}

	// 获取 CPU 数量
	numCPUs := runtime.NumCPU()
	configSlice := make([]filterdnsFilterConfig, numCPUs)
	for i := 0; i < numCPUs; i++ {
		configSlice[i] = config
	}

	if err := objs.ConfigMap.Put(configKey, configSlice); err != nil {
		objs.Close()
		return nil, fmt.Errorf("failed to update config: %w", err)
	}

	// 获取网卡索引
	iface, err := getInterfaceIndex(interfaceName)
	if err != nil {
		objs.Close()
		return nil, fmt.Errorf("failed to get interface index: %w", err)
	}

	// 附加XDP程序到网卡
	xdpLink, err := link.AttachXDP(link.XDPOptions{
		Program:   objs.XdpFilterDns,
		Interface: iface,
		Flags:     link.XDPGenericMode,
	})
	if err != nil {
		objs.Close()
		return nil, fmt.Errorf("failed to attach XDP program: %w", err)
	}

	fmt.Printf("XDP filter-dns attached to interface %s\n", interfaceName)
	if listMode == ListModeWhitelist {
		fmt.Println("Whitelist mode: Only DNS traffic from whitelisted IPs will pass")
	} else if listMode == ListModeBlacklist {
		fmt.Println("Blacklist mode: DNS traffic from blacklisted IPs will be dropped")
	} else {
		fmt.Println("Only DNS traffic (port 53) will pass, all other traffic will be dropped")
	}

	return &FilterDNS{
		objs:    objs,
		xdpLink: xdpLink,
		iface:   interfaceName,
	}, nil
}

// loadIPList 从文件加载IP列表到BPF map
func loadIPList(objs *filterdnsObjects, filename string, isWhitelist bool) error {
	file, err := os.Open(filename)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	ipv4Count := 0
	ipv6Count := 0
	skipped := 0
	dummy := uint8(1)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// 支持CSV格式，取第一列
		fields := strings.FieldsFunc(line, func(r rune) bool {
			return r == ',' || r == ';' || r == '\t'
		})
		if len(fields) == 0 {
			continue
		}
		ipStr := strings.TrimSpace(fields[0])

		// 解析IP地址
		ip := net.ParseIP(ipStr)
		if ip == nil {
			skipped++
			continue
		}

		// 处理IPv4
		if ipv4 := ip.To4(); ipv4 != nil {
			ipInt := binary.BigEndian.Uint32(ipv4)
			if isWhitelist {
				if err := objs.Ipv4Whitelist.Put(ipInt, dummy); err != nil {
					return fmt.Errorf("failed to add IPv4 %s to whitelist: %w", ipStr, err)
				}
			} else {
				if err := objs.Ipv4Blacklist.Put(ipInt, dummy); err != nil {
					return fmt.Errorf("failed to add IPv4 %s to blacklist: %w", ipStr, err)
				}
			}
			ipv4Count++
		} else if ipv6 := ip.To16(); ipv6 != nil {
			// 处理IPv6
			addr := filterdnsIpv6Addr{
				Hi: binary.BigEndian.Uint64(ipv6[0:8]),
				Lo: binary.BigEndian.Uint64(ipv6[8:16]),
			}
			if isWhitelist {
				if err := objs.Ipv6Whitelist.Put(addr, dummy); err != nil {
					return fmt.Errorf("failed to add IPv6 %s to whitelist: %w", ipStr, err)
				}
			} else {
				if err := objs.Ipv6Blacklist.Put(addr, dummy); err != nil {
					return fmt.Errorf("failed to add IPv6 %s to blacklist: %w", ipStr, err)
				}
			}
			ipv6Count++
		}
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading file: %w", err)
	}

	listType := "whitelist"
	if !isWhitelist {
		listType = "blacklist"
	}
	fmt.Printf("Loaded %d IPv4 and %d IPv6 addresses into %s (skipped %d invalid entries)\n",
		ipv4Count, ipv6Count, listType, skipped)

	return nil
}

// GetStats 获取统计信息
func (f *FilterDNS) GetStats() (*Stats, error) {
	var stats filterdnsDnsStats
	key := uint32(0)

	if err := f.objs.StatsMap.Lookup(key, &stats); err != nil {
		return nil, fmt.Errorf("failed to lookup stats: %w", err)
	}

	return &Stats{
		TotalPackets:     stats.TotalPackets,
		DNSPackets:       stats.DnsPackets,
		DroppedPackets:   stats.DroppedPackets,
		WhitelistAllowed: stats.WhitelistAllowed,
		WhitelistDropped: stats.WhitelistDropped,
		BlacklistDropped: stats.BlacklistDropped,
	}, nil
}

// Close 关闭并清理
func (f *FilterDNS) Close() error {
	fmt.Printf("Detaching XDP program from interface %s...\n", f.iface)

	if f.xdpLink != nil {
		if err := f.xdpLink.Close(); err != nil {
			return fmt.Errorf("failed to close XDP link: %w", err)
		}
	}

	if f.objs != nil {
		if err := f.objs.Close(); err != nil {
			return fmt.Errorf("failed to close BPF objects: %w", err)
		}
	}

	fmt.Println("XDP program detached successfully")
	return nil
}

// Run 运行DNS过滤服务
func (f *FilterDNS) Run() error {
	// 监听退出信号
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	fmt.Println("Filter-DNS service running. Press Ctrl+C to stop.")

	// 等待退出信号
	<-sigChan

	return f.Close()
}

// getInterfaceIndex 获取网卡索引
func getInterfaceIndex(name string) (int, error) {
	iface, err := os.ReadFile(fmt.Sprintf("/sys/class/net/%s/ifindex", name))
	if err != nil {
		return 0, fmt.Errorf("interface %s not found: %w", name, err)
	}

	var index int
	_, err = fmt.Sscanf(string(iface), "%d", &index)
	if err != nil {
		return 0, fmt.Errorf("failed to parse interface index: %w", err)
	}

	return index, nil
}
